using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using JPB.DataAccess.Contacts;
using JPB.DataAccess.DbInfoConfig.ClassBuilder;
using JPB.DataAccess.DbInfoConfig.DbInfo;
using JPB.DataAccess.EntityCreator.Core.Contracts;
using JPB.DataAccess.Helper;
using JPB.DataAccess.ModelsAnotations;

namespace JPB.DataAccess.EntityCreator.Core.Compiler
{
	public abstract class ElementCompiler
	{
		private readonly ILogger _logger;

		protected ElementCompiler(string targetDir, string targetCsName, ILogger logger)
		{
			_logger = logger;
			Generator = new ClassInfoGenerator();
			Generator.ClassName = targetCsName;
			TargetDir = targetDir;
		}

		public const string GitURL = "https://github.com/JPVenson/DataAccess";
		public const string AttrbuteHeader = "JPB.DataAccess.EntityCreator.MsSql.MsSqlCreator";

		public ClassInfoGenerator Generator { get; set; }

		public bool WriteAlways { get; set; }
		public string TargetDir { get; private set; }
		public string TableName { get; set; }

		public string TargetCsName
		{
			get { return Generator.ClassName; }
		}

		public string Name
		{
			get { return Generator.ClassName; }
		}

		/// <summary>
		///		What type of Element is this. e.g. Table/View/StoredProcedure
		/// </summary>
		public abstract string Type { get; set; }

		public bool CompileHeader { get; set; }

		public bool GenerateConfigMethod { get; set; }

		public string Namespace
		{
			get { return Generator.Namespace; }
			set { Generator.Namespace = value; }
		}

		public abstract void PreCompile();

		public virtual void Compile(IEnumerable<IColumInfoModel> columnInfos, bool splitByType, Stream to = null)
		{
			if (to != null)
			{
				if (!to.CanSeek)
					throw new InvalidOperationException("The stream must be seekable");
				if (!to.CanWrite)
					throw new InvalidOperationException("The stream must be writeable");
			}

			PreCompile();
			if (string.IsNullOrEmpty(TableName))
			{
				TableName = TargetCsName;
			}

			if (CompileHeader)
			{
				Generator.CompilerHeader.Add("<author>");
				Generator.CompilerHeader.Add("<created-by>" + Environment.UserDomainName + @"\" + Environment.UserName + "</created-by>");
				Generator.CompilerHeader.Add("<created-on> " + DateTime.Now.ToString("yyyy MMMM dd") + "<created-on>");
				Generator.CompilerHeader.Add("</author>");
			}

			if (string.IsNullOrEmpty(Namespace))
			{
				Generator.Namespace = "JPB.DataAccess.EntryCreator.AutoGeneratedEntrys";
			}
			else
			{
				Generator.Namespace = Namespace;
			}
			var generatedCodeAttribute = new System.CodeDom.Compiler
				.GeneratedCodeAttribute(AttrbuteHeader, "2.0.0.0");
			Generator.GeneratedCodeAttribute = generatedCodeAttribute;

			Generator.GenerateConfigMethod = GenerateConfigMethod;
			if (TableName != TargetCsName)
			{
				Generator.Attributes.Add(new AttributeInfo()
				{
					Name = nameof(ForModelAttribute),
					ConstructorSetters =
					{
						{"alternatingName", "\"" + TableName + "\""}
					}
				});
			}

			Generator.NamespaceImports.Add("System");
			Generator.NamespaceImports.Add("System.Collections.Generic");
			Generator.NamespaceImports.Add("System.CodeDom.Compiler");
			Generator.NamespaceImports.Add("System.Linq");
			Generator.NamespaceImports.Add("System.Data");
			Generator.NamespaceImports.Add(typeof(ForModelAttribute).Namespace);

			using (var memStream = new MemoryStream())
			{
				using (var writer = new StreamWriter(memStream, Encoding.UTF8, 128, true))
				{
					writer.NewLine = Environment.NewLine;
					writer.Write(Generator.RenderPocoClass());
					_logger.WriteLine("Generated class" + Generator.ClassName);
					writer.Flush();
				}

				_logger.WriteLine("Compute changes");
				//check if hascodes are diverent
				var hasher = MD5.Create();
				var neuHash = hasher.ComputeHash(memStream.ToArray());
				var targetDirectory = TargetDir;

				if (splitByType)
				{
					targetDirectory = Path.Combine(targetDirectory, Type);
				}

				var targetFileName = Path.Combine(targetDirectory, Generator.ClassName + ".cs");
				if (to == null)
				{
					using (var fileStream = new FileStream(targetFileName, FileMode.OpenOrCreate))
					{
						var exisitingHash = hasher.ComputeHash(fileStream);
						if (!exisitingHash.SequenceEqual(neuHash))
						{
							_logger.WriteLine("Class changed. Old file will be kept and new contnt will be written");
							fileStream.SetLength(0);
							fileStream.Flush();
							fileStream.Seek(0, SeekOrigin.Begin);
							memStream.WriteTo(fileStream);
							memStream.Flush();
							fileStream.Flush();
						}
					}
				}
				else
				{
					var exisitingHash = hasher.ComputeHash(to);
					if (WriteAlways || !exisitingHash.SequenceEqual(neuHash))
					{
						_logger.WriteLine("Class changed. Old file will be kept and new contnt will be written");
						to.SetLength(0);
						to.Flush();
						to.Seek(0, SeekOrigin.Begin);
						memStream.WriteTo(to);
						memStream.Flush();
						to.Flush();
					}
				}
			}
		}
	}
}