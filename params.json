{
  "name": "Dataaccess",
  "tagline": "This is Yet another ORM that uses various Technology's without 3rd Party to Map database output to POCOs. ",
  "body": "[![Build status](https://ci.appveyor.com/api/projects/status/vatab1g9oyo6sriq/branch/master?svg=true)](https://ci.appveyor.com/project/JPVenson/dataaccess/branch/master)\r\n\r\nThis work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.\r\n\r\nYou can also contact me on gitter at https://gitter.im/JPVenson/DataAccess.\r\n\r\n## Introduction\r\nThis will be a short article about my multi strategy ADO.NET wrapper that uses FactoryMethods,\r\nReflection or a combination of both. It is simple to use,\r\nbut a complex and powerful solution for simple and fast (fast in Development and usage) database access.\r\n\r\nTo be clear, this is designed to be a helper for very simple work. It is not created to be an EF alternative!\r\n\r\n## Background\r\nWell, the background of this project was that most of my colleagues worked with a very old and oversized solution that needed a lot of maintenance and changes when we started with a new project and even for simple statements like:\r\n\r\n```SQL\r\nSELECT * FROM Foo\r\n```\r\nI was forced to manually open a connection, run the statement and parse the IDataReader. I thought this is absolutely not necessary because: Most of the time, the POCOs are designed like the database with properties that are named like Column names and so on. So, this was a task I’d tried to automate.\r\n\r\nI'd like to present my solution and I hope to get some nice ideas from you.\r\n\r\n# Using the Code\r\nThe main parts are the IDatabase, IDatabaseStrategy and for the Main Reflection and loading the DbAccessLayer.\r\n\r\nIDatabase defines a ínterface that maintains a Connection, this means to open a Connection, keep it open as long as it is necessary and then close it. In IDatabase, there is an IDatabaseStrategy that is used to connect to certain databases like MySQL, MsSql, OleDB and so on. The lib supports MsSQL, Obdc, OleDb from the hood, but in others, in the project included Assemblies, there are also implementations for MySQL and SqLite.\r\n\r\nAs I mentioned, there are multiple ways to load or submit data from and to a database.\r\n\r\nFor example: the simple Select from a database. We expect to be a database that is called Northwind and a Table Foo.\r\n\r\nCreate an Object that is called like your Table (Foo)\r\nDefine properties that are named and of the same type like a Column\r\nCreate a new Object of DbAccessLayer with a proper connection string Call\r\n```C#\r\n Select<Foo>\r\n\t();\r\n\t```\r\nIn these 4 steps, you will execute a complete select to the database and then the result will be mapped with Reflection to the Object.\r\n\r\n```C#\r\npublic class FooTest\r\n{\r\npublic class Foo\r\n{\r\npublic long Id_Foo { get; set; }\r\npublic string FooName { get; set; }\r\n}\r\n\r\npublic FooTest()\r\n{\r\nvar accessLayer = new DbAccessLayer(DbTypes.MsSql,\r\n\"Data Source=(localdb)\\\\Projects;Initial Catalog=Northwind;Integrated Security=True;\");\r\nvar @select = accessLayer.Select<Foo>\r\n();\r\n}\r\n}\r\n```\r\nThere are A LOT of overloads of Select, SelectNative, SelectWhere and RunPrimetivSelect. Almost all methods with a Generic Parameter have a corresponding method that accepts a Type instance.\r\n\r\nIn all examples, when an instance of DbAccessLayer is needed, it will be represented by the variable.\r\n\r\naccessLayer\r\nand in the testing, an MsSQL Db is used and its syntax.\r\n\r\n# Creating and Customizing a POCO\r\nThis is primarily an Object Relationship Mapper. That means that this lib always tries to map the output that is returned by a Query into an Object that has multiple properties. You have some attributes that define certain parts and functions of that object.\r\n\r\nAs seen in the example, you can skip all extra configuration when you follow some rules. To \"bypass\" these rules like the Rule that a Class must be named the same, then the Table you can set an Attribute.\r\n\r\n## ForModel\r\n\r\n```C#\r\n[ForModel(\"Foo\")]\r\npublic class NotFooButSomeStrangeNameYouDoNotLike\r\n{\r\npublic long Id_Foo { get; set; }\r\n[ForModel(\"FooName\")]\r\npublic string Metallica4tw { get; set; }\r\n}\r\n```\r\nThe ForModel attribute is allowed on Class | Table and on Property | Column level. It gives the Processor the information that the name that is used in the POCO must be mapped to the Table.\r\n\r\n## PrimaryKey\r\n\r\n```C#\r\npublic class Foo\r\n{\r\n[PrimaryKey]\r\npublic long Id_Foo { get; set; }\r\npublic string FooName { get; set; }\r\n}\r\n```\r\nThe PrimaryKey attribute marks a Property ... what a wonder, to be an PrimaryKey on the database. With this function, you can call:\r\n```C#\r\naccessLayer.Select<Foo>\r\n(155151 /*This is the PrimaryKey we are looking for*/);\r\n```\r\n## InsertIgnore\r\n\r\nMarks a Property to be not Automatically included into a InsertStatement. Per default, the PrimaryKey inherits from this attribute.\r\n\r\n## ForeignKey (Work In Progress)\r\n\r\nWell, some good long day when my work was not so hard, I’d thought that it would be fun, when it would be nice that the Automatic process could load NavigationPropertys too. The Term NavigationProperty is from EF and defined as:\r\n\r\n\"Represents the navigation from one entity type to another entity type in the conceptual model.\"\r\n\r\nSo a NavProperty is not more than an Property that is of the Type that another Object and that Relation is described with an ForeignKey.\r\n\r\n```C#\r\npublic class FooTest\r\n{\r\npublic class Foo\r\n{\r\n[PrimaryKey]\r\npublic long Id_Foo { get; set; }\r\npublic string FooName { get; set; }\r\n\r\npublic long Image_Id { get; set; }\r\n\r\n/// <summary>\r\n/// A Property that is of the type that is referred to\r\n/// 1 TO 1 relation\r\n///\r\n</summary>\r\n[ForeignKey(\"Image_Id\")]\r\npublic virtual Image img { get; set; }\r\n\r\n/// <summary>\r\n/// A Property that is a List of the type that is referred to\r\n/// 1 TO Many relation\r\n///\r\n</summary>\r\n[ForeignKey(\"Image_Id\")]\r\npublic virtual IEnumerable<Image>\r\nimgs { get; set; }\r\n}\r\n\r\npublic class Image\r\n{\r\n[PrimaryKey]\r\npublic long Id_Image { get; set; }\r\npublic byte[] ImageData { get; set; }\r\n}\r\n}\r\n```\r\nAs written, this is a feature that has its known issues / bugs / problems:\r\n\r\nThe Select is one time, changes that are made to the collection are not observed by the manager.\r\nThe Foreign POCO must have exactly one PrimaryKey property, when it finds more than one, the first will be taken.\r\nOnly Egar loading is supported. When loading a big object tree, all objects are loaded at once.\r\n\r\n## LoadNotImplimentedDynamic\r\n\r\nWhen the Select statement returns more information than build in the POCO, this property\r\n(must have this signature):\r\n\r\n```C#\r\n[LoadNotImplimentedDynamic]\r\npublic IDictionary<string, object>\r\nUnresolvedObjects { set; get; }\r\n```\r\n(Property Name does not matter) it will be filled with the data (see FactoryMethods).\r\n\r\n## IgnoreReflection\r\n\r\nSimple: as the XmlIgnore attribute, it marks a Property to not be indexed and accessed by any function of the Mapper. Even if the result contains a Column that matches this property, the property will not be used.\r\n\r\n## RowVersion\r\n\r\nDefines a RowVersion attribute. When defined, all calls of `accessLayer.Update()` and `accessLayer.Refresh()` will use this Property to check for changes.\r\n\r\n### Loading Strategies\r\nThere are 2 ways of loading with factory methods defined inside the POCO or automatically with customization over attributes. The 2nd way will be the fallback when there are no or not the right Factory available.\r\n\r\n## Constructor and Method Injection\r\n\r\nThe manager can detect a method to pull statements from it. For example, how you define a method that creates a Select statement without parameter:\r\n\r\n```C#\r\npublic class Foo\r\n{\r\npublic long Id_Foo { get; set; }\r\npublic string FooName { get; set; }\r\n\r\n[SelectFactoryMehtod]\r\npublic static string CreateSelectStatement()\r\n{\r\nreturn \"SELECT * FROM Foo\";\r\n}\r\n}\r\n```\r\nWhen some method is defined, the manager will always use this method to create a Select statement and he will skip any other reflection based creation.\r\n\r\nFor Selects, this is also possible on Class level:\r\n\r\n```C#\r\n[SelectFactory(\"SELECT * FROM Foo\")]\r\npublic class Foo\r\n```\r\n\r\nBut only Selects must be Public and Static. Update, Insert and Delete Factory’s must be Not static. You can return a string OR an instance of IQueryFactoryResult. To prevent SqlInjection, this is the HEAVILY recommended way when you work with parameters.\r\n\r\nAn example that uses IQueryFactoryResult for Update and Delete and a String for Select:\r\n\r\n```C#\r\n[SelectFactory(\"SELECT * FROM Foo\")]\r\npublic class Foo\r\n{\r\n\tpublic long Id_Foo { get; set; }\r\n\tpublic string FooName { get; set; }\r\n\r\n\t[DeleteFactoryMethod]\r\n\tpublic IQueryFactoryResult CreateDeleteStatement()\r\n\t{\r\n\t\tvar result = new QueryFactoryResult(\"DELETE FROM Foo WHERE Id_Foo = @1\",\r\n\t\tnew QueryParameter()\r\n\t\t{\r\n\t\tName = \"@1\", Value = Id_Foo\r\n\t});\r\n\treturn result;\r\n}\r\n\r\n[UpdateFactoryMethod]\r\npublic IQueryFactoryResult CreateSomeKindOfUpdate()\r\n{\r\n\tvar result = new QueryFactoryResult(\"Update Foo SET FooName = @param WHERE Id_Foo = @1\",\r\n\tnew QueryParameter()\r\n\t{\r\n\t\tName = \"@1\",\r\n\t\tValue = Id_Foo\r\n\t},\r\n\tnew QueryParameter()\r\n\t{\r\n\t\tName = \"@param\",\r\n\t\tValue = FooName\r\n\t});\r\n\treturn result;    \r\n}\r\n```\r\nIt is possible to transfer parameters from the caller to the function. When the caller provides you parameters, they will be given to the function that has the same signature then the parameter. This idea is more or less shamelessly stolen from the ASP.NET MVC approach.\r\n\r\nAfter version 2.0.0.14 you can also use an QueryBuilder or QueryBuilderX on a void Method to create your Statements.\r\n\r\n```C#\r\npublic class FooTest\r\n{\r\n\tpublic class Foo\r\n\t{\r\n\t\tpublic long Id_Foo { get; set; }\r\n\t\tpublic string FooName { get; set; }\r\n\r\n\t\t[UpdateFactoryMethod]\r\n\t\tpublic static IQueryFactoryResult CreateSomeKindOfUpdate(string someExternalInfos)\r\n\t\t{\r\n\t\t\tif (string.IsNullOrEmpty(someExternalInfos))\r\n\t\t\treturn null; //Noting to do here, use the Automatic loading\r\n\r\n\t\t\tvar result = new QueryFactoryResult\r\n\t\t\t(\"SELECT * FROM Foo f WHERE f.FooName = @info\", \r\n\t\t\tnew QueryParameter()\r\n\t\t\t{\r\n\t\t\t\tValue = someExternalInfos,\r\n\t\t\t\tName = \"@info\"\r\n\t\t\t});\r\n\t\t\treturn result;\r\n\t}\r\n\r\n\r\n\tpublic FooTest()\r\n\t{\r\n\t\tvar access = new DbAccessLayer(DbTypes.MsSql, \"Data Source=(localdb)\\\\Projects;Initial Catalog=Northwind;Integrated Security=True;\");\r\n\t\tvar @select = access.Select<Foo>(\"SomeName\");\r\n\t}\r\n}\r\n```\r\nThe string that we provided to...\r\n\r\n```C#\r\naccess.Select<Foo>(\"SomeName\");\r\n```\r\n...will be given to the Select function to create a statement and this statement will be executed.\r\n\r\nIt is also possible to control the Loading from a DataRecord to your class by using a Constructor that accepts these parameters:\r\n\r\n```C#\r\npublic class Foo\r\n{\r\n\t[ObjectFactoryMethod]\r\n\tpublic Foo(IDataRecord record)\r\n\t{\r\n\t\tId_Foo = (long)record[\"Id_Foo\"];\r\n\t\tFooName = (string)record[\"FooName\"];\r\n\t}\r\n\r\n\tpublic long Id_Foo { get; set; }\r\n\tpublic string FooName { get; set; }\r\n}\r\n```\r\nWhen it is necessary to create a new Instance of that Poco, there is always a IDataRecord to load it from so via Constructor injection, we find this one and provide him the data.\r\n\r\n## XML Field Loading\r\nThere is a new attribute:\r\n\r\n## FromXmlAttribute\r\nIt allows a simple loading of Objects from an XML Serialized Column. The attribute contains two parameters:\r\n\r\nFieldName [Required]\r\nLoadStrategy [Optional]\r\nThe first Param has the same effect as the ForModel one.\r\n\r\nThe last Param defines the usage of this Property.\r\n\r\nShould it be included into a Select Statement => Column exists\r\n\r\nShould it be excluded from Select Statement => Column does not exist but will be added by Statement\r\n\r\nIn both cases, if the Column exists in the result stream, it will be tried to deserialized into the type that the Property defines. If this is an implementation or IEnumerable<T>\r\n\t, the result should also be formatted as list.\r\n\r\n\t# Attributeless Configuration\r\n\tAs suggested from user Paulo Zemek, I modified the Reflection only MetaData API to support runtime manipulation of the Metadata.\r\n\r\n\tTo configurate any object, you have to instantiate a Config class. It acts as an Fassade to the internal API.\r\n\r\n\tTo extend the reflection based behavior, you have to call the SetConfig method on any Config instance. In the given callback, you have access to several methods that will add the attribute information like ForModel and so on. All helper methods are using the 3 base methods:\r\n\r\n\t```C#\r\n\tpublic void SetPropertyAttribute<TProp>\r\n\t\t(Expression<Func<T, TProp>> exp, DataAccessAttribute attribute)\r\n{\r\n\tvar classInfo = config.GetOrCreateClassInfoCache(typeof(T));\r\n\tvar info = ConfigHelper.GetPropertyInfoFromLabda(exp);\r\n\tvar fod = classInfo.GetOrCreatePropertyCache(info);\r\n\tfod.AttributeInfoCaches.Add(new AttributeInfoCache(attribute));\r\n}\r\n```\r\n\r\n```C#\r\npublic void SetMethodAttribute<TProp>(Expression<Func<T, TProp>> exp, DataAccessAttribute attribute)\r\n{\r\n\tvar classInfo = config.GetOrCreateClassInfoCache(typeof(T));\r\n\tvar info = ConfigHelper.GetMehtodInfoFromLabda(exp);\r\n\tvar fod = classInfo.MethodInfoCaches.First(s => s.MethodName == info);\r\n\tfod.AttributeInfoCaches.Add(new AttributeInfoCache(attribute));\r\n}\r\n```\r\n\r\n```C#\r\npublic void SetClassAttribute(DataAccessAttribute attribute)\r\n{\r\n\tvar classInfo = config.GetOrCreateClassInfoCache(typeof(T));\r\n\tclassInfo.AttributeInfoCaches.Add(new AttributeInfoCache(attribute));\r\n}\r\n```\r\nYou could use these methods directly to add data to the internal ConfigStore or the helper one:\r\n\r\n```C#\r\npublic void SetForModelKey<TProp>(Expression<Func<T, TProp>> exp, string value)\r\n{\r\n\tSetPropertyAttribute(exp, new ForModel(value));\r\n}\r\n```\r\n\r\nIn one of the next releases, I will provide you a way for loading and store all these data in XML. All type information can be accessed by using the static methods in the Config class. That would allow you to reuse the type information.\r\n\r\nAll type access parts as ThreadSave.\r\n\r\nThere are two ways in managing configs:\r\n\r\n- From Outside\r\n\r\nYou can call anywhere in your code:\r\n\r\n```C#\r\nnew Config().SetConfig<T>(s => { ... })\r\n```\r\nThis allows you to configurate a well known POCO in all ways. The generated information will be added to the LocalConfig Store.\r\n\r\n- From Inside\r\n\r\nHurray! A new Attribute is there! The ConfigMehtodAttribute. You can decorate a static method with its attribute that will take a Config instance and then it allows you to configurate yourself inside the class itself.\r\n\r\n### Speed Test\r\nLately, I was evaluating YAORM against other ORM's with Frans Bouma's RawBencher. I recognize that the current version has some extremely critical problems with some ... let's call it \"Non optimal POCO\" usage. As YAORM depends heavily on a ADO.NET conform constructor and only uses Reflection as some kind of fallback method, this way was extremely slow. In its test, it took about 6,000 ms to enumerate all 31465 entries. That was darn slow compared to EntityFramework, and don't even mention Dapper ;-).\r\n\r\nSo I made some major improvements to these POCOs that are not self containing and ADO.NET Constructor.\r\n\r\n> ADO.NET Constructor:\r\n>\r\n> I was talking about an Ado.net conform Ctor. This kind of Constructor is defined by an POCO and takes an instance of IDataReader | IDataRecord and reads all necessary fields from the result set and then sets and/or converts these values to its properties.\r\n\r\nAfter I made the changes to the existing code, including auto code creation due Runtime and the usage of compiled lambdas instead of the heavy usage of the reflection API, I was extremely surprised. From 6,000 ms down to 320 ms. With this test, I also made some improvements and changes to the new Config API like:\r\n\r\n### Static Factory setting\r\nMultibe pre-defined setter for Attributes on Properties\r\nControl over the InMemory ADO.NET Ctor creation\r\n\r\n# Internal Reflection\r\nThe ORM uses an Internal Reflection/IL/Expressions/CodeDom provider to generate most of the needed code due runtime.\r\n\r\nThere is a mixture of these technologys because some parts where just to timeconsuming to be implimented in IL. That is true for the CodeDOM part which are used to generate an Constructor due Runtime to load entitys. This was first used only by the EntityCreator but then also modifyed to be called due runtime. All reflection based work is located inside the MetaAPI and derived for the ORM.\r\n\r\n> The MetaAPI uses IL and Expressions to compile accessors for Propertys and Methods. Methods are wrapped into an IL DynamicMethod and propertys are wrapped in Expressions\r\n\r\nIn future the basic Reflection API (MetaAPI) will may be moved to an very own Assambly because it is desgined to be generic. The most basic store to access everything is the \r\n\r\n```C#\r\npublic class MetaInfoStore<TClass, TProp, TAttr, TMeth, TCtor, TArg> : \r\n\tIDisposable\r\n\twhere TClass : class, IClassInfoCache<TProp, TAttr, TMeth, TCtor, TArg>, new()\r\n\twhere TProp  : class, IPropertyInfoCache<TAttr>, new()\r\n\twhere TAttr  : class, IAttributeInfoCache, new()\r\n\twhere TMeth  : class, IMethodInfoCache<TAttr, TArg>, new()\r\n\twhere TCtor  : class, IConstructorInfoCache<TAttr, TArg>, new() \r\n\twhere TArg   : class, IMethodArgsInfoCache<TAttr>, new()\r\n```\r\nAs is said it is desgined to be generic and reusable. It contains a class to convert an Type instance to an instance of TClass by using the GetOrCreateClassInfoCache method. This method is of course also Recusiv and aware of that, it will ether give you an instance from the local store or enumerates all \"Most used Infos\". That means it will enumerate throu all Propertys, Methods, Arguments, Constructors and Attributes on each of them and store them. This class is optional ThreadSave by using the EnableThreadSafety property. This optional property was introduced to ensure a maximum of Performance.\r\n\r\nThis class can be ether Global or InstanceLocal. By using the constructor\r\n\r\n```C#\r\npublic MetaInfoStore(bool isGlobal)\r\n```\r\nYou can spezify that. To ensure a maximum of Performance you can also Impliment for example the IPropertyInfoCache and override the Init mehtod to define new Attributes that are common accessed. This brings a huge performance advance because otherwise you have to loop through the collection of all Attributes to find the desired one what, of course is timeconsuming. Take a look into the DbPropertyInfoCache to see examples.\r\n\r\nAn other good reason to use this, is the advantage of adding \"fake\" propertys and Attributes due Runtime by simply adding them to the collections. This feature is used by the ConfigAttribute to extend POCOs. Each part of the YAORM is using this Store and if you add a new Property to it, it will find it. For example the MethodInfoCache is implimenting an Constructor:\r\n\r\n```C#\r\ninternal MethodInfoCache(Func<object, object[], object> fakeMehtod, string name = null, params TAtt[] attributes)\r\n```\r\nThis allows you to add each method you want to each class without using .net Tricks such as dynamic's.\r\n\r\n# LocalDbRepository\r\nIts an Collection that will enforce ForginKeyDeclarationsAttributes in future also ForginKeyAttributes. With this class you can define local Databases inside a scope. All \"tables\" inside this scope will be validates if you add any object to it and if you try to add an Entity to it which would violate ForeignKey's an exception is thrown.\r\n\r\nFirst you have to setup an DatabaseScope\r\n\r\n```C#\r\nusing (new DatabaseScope())\r\n{\r\n\r\n}\r\n```\r\nThis scope will be an Container and validates multibe Tables that are defined inside the Scope. This syntax was takes from the TransactionScope that exists within the .netFramework. Then you have to define tables by creating them inside the scope\r\n\r\n```C#\r\nusing (new DatabaseScope())\r\n{\r\n\t_books = new LocalDbReposetory<Book>();\r\n\t_images = new LocalDbReposetory<Image>();\r\n}\r\n```\r\nThe defintion for Book and Image is folloring:\r\n\r\n```C#\r\npublic class Image\r\n{\r\n\t[PrimaryKey]\r\n\tpublic long ImageId { get; set; }\r\n\r\n\tpublic string Text { get; set; }\r\n\r\n\t[ForeignKeyDeclaration(\"BookId\", typeof(Book))]\r\n\tpublic int IdBook { get; set; }\r\n}\r\n```\r\n\r\n```C#\r\npublic class Book\r\n{\r\n\t[PrimaryKey]\r\n\tpublic int BookId { get; set; }\r\n\r\n\tpublic string BookName { get; set; }\r\n}\r\n```\r\n\r\nIt is important to decorate an PrimaryKeyAttribute and also an ForeignKeyDeclarationAttribute to define valid connections between both Tables. You can ether use Attributes or an Config method (s.a). The first argument on the ForgeinKeyDeclarationAttribute will be soon obsolete. You can use the Constructor of the LocalDbReposetory to define an PrimaryKey generator if you use PrimaryKeys that are not of type of Long, Int, Guid or if you want to define other Autoincriment by 1 and starting with 1.\r\n\r\n## Version 2.0.180\r\n\r\n\r\n### Trigger\r\nIn the latest version you can hook all DDL triggers (MsSQL) on a local collection. Supported are:\r\n- WITH REPLICATION\r\n- WITHOUT REPLICATION\r\n\r\nThen on both\r\n\r\n- AFTER\r\n- BEFORE\r\n- INSTEAD OF\r\n\r\nThen on all\r\n\r\n- INSERT\r\n- UPDATE\r\n- DELETE\r\n\r\nFrom LocalDbTriggerTestNotInReplication:\r\n\r\n```C#\r\nLocalDbRepository<Users> repro;\r\nusing (var db = new DatabaseScope())\r\n{\r\n\trepro = new LocalDbRepository<Users>(new DbConfig());\r\n}\r\nvar orderFlag = false;\r\nrepro.Triggers.NotForReplication.For.Insert += (sender, token) =>\r\n{\r\n\tAssert.That(orderFlag, Is.False);\r\n\torderFlag = true;\r\n};\r\nrepro.Triggers.NotForReplication.After.Insert += (sender, token) =>\r\n{\r\n\ttoken.Cancel(\"AFTER\");\r\n};\r\nAssert.That(orderFlag, Is.False);\r\nAssert.That(() =>\r\n{\r\n\trepro.Add(new Users());\r\n}, Throws.Exception.InstanceOf<ITriggerException>().With.Property(\"Reason\").EqualTo(\"AFTER\"));\r\nAssert.That(orderFlag, Is.True);\r\nAssert.That(repro.Count, Is.EqualTo(0));\r\n```\r\n\r\n## Constraints\r\n\r\nAs there are trigger there are also Constraints you can add to any Table.\r\n\r\nAll Contraints have to be added due creation of an database. That means you must use the example code in the DatabaseScope. This restriction was made to enforce that all Entities always match the given constrains.\r\n\r\nThere is support for:\r\n\r\n- Check\r\n  - Adds a check that will be enforced when an Item is Inserted or Updated\r\n- Unique\r\n  - Adds a check that will be enforced when an Item is Inserted or Updated\r\n- Defaults\r\n  - Adds a check that will be enforced when an Item is Inserted or Updated\r\n\r\nFrom LocalDbWithConstraintsTest:\r\n\r\n```C#\r\npublic LocalDbRepository<Image> TestInit(IEnumerable<ILocalDbCheckConstraint<Image>> checks,\r\n\t\t\tIEnumerable<ILocalDbUniqueConstraint<Image>> unique,\r\n\t\t\tIEnumerable<ILocalDbDefaultConstraint<Image>> defaults)\r\n{\r\n\tLocalDbRepository<Image> images;\r\n\tusing (new DatabaseScope())\r\n\t{\r\n\t\timages = new LocalDbRepository<Image>(new DbConfig());\r\n\t\tif (checks != null)\r\n\t\t\tforeach (var localDbCheckConstraint in checks)\r\n\t\t\t{\r\n\t\t\t\timages.Constraints.Check.Add(localDbCheckConstraint);\r\n\t\t\t}\r\n\t\tif (unique != null)\r\n\t\t\tforeach (var localDbCheckConstraint in unique)\r\n\t\t\t{\r\n\t\t\t\timages.Constraints.Unique.Add(localDbCheckConstraint);\r\n\t\t\t}\r\n\t\tif (defaults != null)\r\n\t\t\tforeach (var localDbCheckConstraint in defaults)\r\n\t\t\t{\r\n\t\t\t\timages.Constraints.Default.Add(localDbCheckConstraint);\r\n\t\t\t}\r\n\t}\r\n\treturn images;\r\n}\r\n\r\n[Test]\r\npublic void AddCheckConstraint()\r\n{\r\n\tvar images = TestInit(new[]{new LocalDbCheckConstraint<Image>(\"TestConstraint\", s =>\r\n\t{\r\n\t\tvar item = s;\r\n\t\treturn item.IdBook > 0 && item.IdBook < 10;\r\n\t})}, null, null);\r\n\r\n\tvar image = new Image();\r\n\timage.IdBook = 20;\r\n\tAssert.That(() => images.Add(image), Throws.Exception.TypeOf<ConstraintException>());\r\n\timage.IdBook = 9;\r\n\tAssert.That(() => images.Add(image), Throws.Nothing);\r\n\tAssert.That(images.Count, Is.EqualTo(1));\r\n}\r\n```\r\n\r\nNote:\r\nThere are implementations for all 3 constraints. For the Default constraint there are 2:\r\n- LocalDbDefaultConstraint<TEntity, TValue>\r\n- LocalDbDefaultConstraintEx<TEntity, TValue>\r\n\r\nLocalDbDefaultConstraint: Will always update the value no matter what value was inside the entitie\r\n\r\nLocalDbDefaultConstraintEx: Will check the value for its Default(by using C# default() operator) and if its not equals the default value it will set an predefined value\r\n\t\r\n\r\n# Entity Creator\r\nThe lib now contains a Console Application that will be possible to create Entities based on a database. At the Current state (01.Nov.2014), only MsSql databases are supported and the testing is very basic.\r\n\r\nThe usage is simple in its basic component but has a lot of potential. And also, the idea here is to re-write the current CommandoLine tool to support complete parameterised works.\r\n\r\nAfter you start the program, it will ask you for a Target directory (where the generated files will be stored) and a connection string.\r\n\r\n\r\n\r\nAfter that, you will see some information from that database including Tables, StoredProcedures and Views. Views are handled the same as Tables are because the calling syntax is pretty much the same.\r\n\r\nWith typing a Number of a Table, Sp or View, you can alter the settings of that object. Other commands are:\r\n\r\n\\compile\r\n\\autoGenNames\r\n\\add\r\nYou start the process:\r\n\r\nStarts the compiling of all Tables, SPs and views that are not excluded\r\nStarts a simple renaming process that will Save Remove all '_',' ' chars from the database names and replacing them with C# Conform names\r\nNot implemented (In future, it will be possible to add static loader constructors. This will dramatically increase the selecting performance. But due to the newest feature (XML based loading), this is not completely implemented).\r\nChanges in Version 2.0\r\n\r\nMore Unit tests (yeeea)\r\n- Mapping from DB fields to Class properties is now stored inside the ClassInfoCache and is persisted\r\n- The Reflection API now uses HashSets instead of lists\r\n- DataConverterExtentions are reduced\r\n- PropertyInfoCache is now used to access Properties directly by using dynamic compiled Lambdas\r\n- A Static factory method Delegate on ClassInfoCache level is now taking care of the creation of POCOs\r\n- Some methods from the EntityCreator are moved from the EXE to the DataAccess.dll\r\n- A new class \"FactoryHelper\" is now capable of creating ADO.NET Ctor due Runtime by using the improved methods of the EntityCreator\r\nMajor improvements in ctor creation the EntityCreator and the Runtime creator are now capable of constructors for:\r\n  - (Single)XML\r\n  - (List)XML\r\n  - (Single)ForginKey\r\n  - (List)ForginKey\r\n  - ValueConverter\r\n  - Null Values\r\n  - (Possible)Null Values\r\n  - ForModel\r\n  - Added Multibe Comments\r\n  - Removed the Linq Provider completely\r\n  - Replaced the ReposetoryCollection with the DbCollection\r\n  - Bug fixing\r\n \r\n# Points of Interest\r\nThis project has brought me a lot of fun and one or two sleepless nights and I guess they will not be the last I had because of this. The lib contains a small Linq Provider that is marked as obsolete because, due to the implementation and development, I was ... let's say I was annoyed by Linq.\r\n\r\nI expect from this project to have some ideas and more to improve my work.\r\n\r\nThanks to everyone that took the time to read this. Thanks also to my trainer Christian H. for his impressions and help.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}